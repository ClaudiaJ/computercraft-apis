-- Generalized Event Tables
--

events = {
  on = function(t, name, responder)
    local responders = t[name] or {}
    table.insert(responders, responder)
    t[name] = responders
  end,

  off = function(t, name, responder)
    local responders = t[name]
    if responder and responders then
      local newResponders = {}
      for i=1,#responders do
        if responders[i] ~= responder then
          table.insert(newResponders, responders[i])
        end
      end
      t[name] = newResponders
    else
      t[name] = {}
    end
  end,

  send = function(t, name, ...)
    local responders = t[name] or {}
    local sent = false
    for i, responder in ipairs(responders) do
      responder(...)
      sent = true
    end
    return sent
  end,

  new = function()
    local t = {}
    t.on = function(...) events.on(t, ...) end
    t.off = function(...) events.off(t, ...) end
    t.send = function(...) events.send(t, ...) end
    return t
  end
}

local OSEvents = events.new()

-- Wiring (a better interface for redstone)
--

local WiringEvents = events.new()
local WiringState = nil

wiring = {
  snapshot = function()
    local state = {}
    for _, side in ipairs(rs.getSides()) do
      state[side] = rs.getInput(side)
    end
    return state
  end,

  changes = function(old, new, cb)
    for side, state in pairs(new) do
      local oldState = old[side]
      if state ~= oldState then
        cb(side, state)
      end
    end
  end,

  eventHandler = function()
    local oldState = WiringState
    WiringState = wiring.snapshot()
    wiring.changes(oldState, WiringState, function(side, val)
      WiringEvents.send(side, val)
    end)
  end,

  on = WiringEvents.on,
  off = WiringEvents.off,

  get = function(side)
    rs.getInput(side)
  end,

  set = function(side, val)
    rs.setOutput(side, val)
  end
}
local WiringState = wiring.snapshot()

OSEvents.on("redstone", wiring.eventHandler)

-- Runloop
--

local function runCoroutines(routines)
  local livingRoutines = {}
  for _, thread in ipairs(routines) do
    if coroutine.status(thread) == "suspended" then
      coroutine.resume(thread)
      if coroutine.status(thread) == "suspended" then
        table.insert(livingRoutines, thread)
      end
    end
  end
  return livingRoutines
end

run = function(func)
  local threads = {}
  if func then
    table.insert(threads, coroutine.create(func))
  end
  while true do
    local eventName, p1, p2, p3 = os.pullEventRaw()
    local sent = OSEvents.send(eventName, p1, p2, p3)
    if not sent and eventName == "terminate" then
      print("Shutting down")
      break
    end
  end
end

