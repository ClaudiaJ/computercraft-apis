-- Responder (wraps functions in coroutines)
--

Responder = {}
Responder.__index = Responder

function Responder:new(functionToWrap)
  assert(self, "missing receiver")
  local r = setmetatable({}, self)
  r.func = functionToWrap
  r.co = coroutine.create(r.func)
  return r
end

function Responder:__call(...)
  if self:canResume() then
    local _, check = coroutine.resume(self.co, ...)
    self.check = check
    return true
  else
    return false
  end
end

function Responder:finished()
  return coroutine.status(self.co) == "dead"
end

function Responder:canResume()
  if not self:finished() then
    if self.check then
      return self:check()
    else
      return true
    end
  end
  return false
end

-- EventTable class
--

EventTable = {}
EventTable.__index = EventTable

function EventTable:on(name, responder)
  local responders = self[name] or {}
  table.insert(responders, responder)
  self[name] = responders
end

function EventTable:off(name, responder)
  local responders = self[name]
  if responder and responders then
    local newResponders = {}
    for i=1,#responders do
      if responders[i] ~= responder then
        table.insert(newResponders, responders[i])
      end
    end
    self[name] = newResponders
  else
    self[name] = {}
  end
end

function EventTable:dispatch(name, ...)
  local responders = self[name] or {}
  local sent = false
  for i, responder in ipairs(responders) do
    local f = Responder:new(responder)
    f(...)
    if not f:finished() then
      self:addResponder(f)
    end
    sent = true
  end
  return sent
end

function EventTable:addResponder(responder)
  table.insert(self._unfinishedResponders, responder)
end

function EventTable:resume()
  local newUnfinishedResponders = {}
  for _, responder in ipairs(self._unfinishedResponders) do
    responder()
    if not responder:finished() then
      table.insert(newUnfinishedResponders, responder)
    end
  end
  self._unfinishedResponders = newUnfinishedResponders
end

function EventTable:new()
  assert(self, "missing receiver")
  local et = setmetatable({}, self)
  et._unfinishedResponders = {}
  return et
end

-- create the event table for handling OS events
--

local osEvents = EventTable:new()

function on(...)
  return osEvents:on(...)
end

function off(...)
  return osEvents:off(...)
end

-- convenience
--

function waitUntil(checkFunc)
  coroutine.yield(checkFunc)
end

-- Timers
--

local timers = {}

on("timer", function(timerID)
  timers[timerID] = true
end)

function wait(seconds)
  local timerID = os.startTimer(seconds)
  waitUntil(function()
    local ready = timers[timerID]
    if ready then
      timers[timerID] = nil
    end
    return ready
  end)
end

-- Running
--

function run(mainFunction)
  -- run the main function, if supplied
  if mainFunction then
    local responder = Responder:new(mainFunction)
    osEvents:addResponder(responder)
    osEvents:resume()
  end

  while true do
    -- wait for events
    local eventName, p1, p2, p3 = os.pullEventRaw()

    -- dispatch the event
    local handled = osEvents:dispatch(eventName, p1, p2, p3)

    -- abort the loop if terminate is unhandled
    if not handled then
      if eventName == "terminate" then
        print("Shutting down")
        break
      end
    end

    -- resume any running handlers
    osEvents:resume()
  end
end
